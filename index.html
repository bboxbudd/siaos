<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Тест по алгоритмам и структурам данных</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
        }
        .option-button {
            transition: all 0.2s ease;
        }
        .option-button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(99, 102, 241, 0.1);
        }
    </style>
</head>
<body>
    <div id="root"></div>

<script type="text/babel">
const { useState, useEffect } = React;

// Функция для перемешивания массива (Fisher–Yates shuffle)
const shuffleArray = (array) => {
  const shuffled = [...array];
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

// Компонент иконок (без изменений)
const Icon = ({ name, size = 20, className = "" }) => {
  const icons = {
    ChevronRight: () => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="9 18 15 12 9 6"></polyline>
      </svg>
    ),
    ChevronLeft: () => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="15 18 9 12 15 6"></polyline>
      </svg>
    ),
    RotateCcw: () => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <polyline points="1 4 1 10 7 10"></polyline>
        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
      </svg>
    ),
    CheckCircle: () => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path>
        <polyline points="22 4 12 14.01 9 11.01"></polyline>
      </svg>
    ),
    XCircle: () => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
        <circle cx="12" cy="12" r="10"></circle>
        <line x1="15" y1="9" x2="9" y2="15"></line>
        <line x1="9" y1="9" x2="15" y2="15"></line>
      </svg>
    )
  };
  const IconComponent = icons[name];
  return IconComponent ? <IconComponent /> : null;
};

// Функция для перемешивания ответов с коррекцией индекса правильного ответа
const shuffleQuestionOptions = (question) => {
  const options = [...question.options];
  const correctIndex = question.correct;
  const correctAnswer = options[correctIndex];

  // Перемешиваем
  const shuffledOptions = shuffleArray(options);
  const newCorrectIndex = shuffledOptions.indexOf(correctAnswer);

  return {
    ...question,
    options: shuffledOptions,
    correct: newCorrectIndex
  };
};

const QuizApp = () => {
  const [questions, setQuestions] = useState([]);
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [selectedAnswer, setSelectedAnswer] = useState(null);
  const [showResult, setShowResult] = useState(false);
  const [score, setScore] = useState(0);
  const [answeredQuestions, setAnsweredQuestions] = useState(new Set());

  useEffect(() => {
    const quizData = [
  {
    "id": 1,
    "question": "Какая структура данных относятся к категории линейных списков?",
    "options": ["Множество", "Бинарное дерево", "Дек", "Массив"],
    "correct": 2
  },
  {
    "id": 2,
    "question": "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в лучшем случае?",
    "options": ["нотация о (о-малое)", "нотация Ω (омега-большое)", "нотация Θ (тета)", "нотация О (о-большое)"],
    "correct": 1
  },
  {
    "id": 3,
    "question": "Бинарное дерево - это:",
    "options": [
      "дерево, у которого каждый узел содержит до двух различных значений",
      "дерево, элементы которого являются двоичными числами",
      "дерево, у которого каждый узел может содержать до двух дочерних узлов",
      "дерево, у которого каждый узел должен содержать два дочерних узла"
    ],
    "correct": 2
  },
  {
    "id": 4,
    "question": "Отличительная особенность алгоритма Бойера-Мура-Хорспула:",
    "options": [
      "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с таблицей префиксов (префикс-функцией)",
      "После каждого неудачного сравнения производится сдвиг образца вправо на количество позиций, равное количеству предшествующих удачных сравнений",
      "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
      "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с эвристикой стоп-символов (\"плохих\" символов)"
    ],
    "correct": 3
  },
  {
    "id": 5,
    "question": "Какое из условий проверяется при определении сбалансированности красно-черного дерева?",
    "options": [
      "Количество красных или черных узлов в левом и правом поддеревьях равны",
      "Высота левого и правого поддерева равны",
      "Любой путь от корня дерева к листу содержит одно и то же число черных узлов",
      "Любой путь от корня дерева к листу содержит одно и то же число красных узлов"
    ],
    "correct": 2
  },
  {
    "id": 6,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в худшем случае?",
    "options": ["f(n)=ϴ(log(n))", "f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(1)"],
    "correct": 1
  },
  {
    "id": 7,
    "question": "Какие отношения между элементами поддерживает структура данных бинарное дерево?",
    "options": ["Двоичные", "Иерархические", "Сложные", "Бинарные"],
    "correct": 1
  },
  {
    "id": 8,
    "question": "В основе алгоритма Рабина-Карпа используется:",
    "options": [
      "Префикс-функция",
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Эвристика \"хороших\" суффиксов",
      "Хеш-функция"
    ],
    "correct": 3
  },
  {
    "id": 9,
    "question": "В какой последовательности располагаются вершины дерева при прямом обходе (preorder):",
    "options": [
      "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15",
      "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15",
      "8, 9, 4, 10, 11, 5, 2, 12, 13, 6, 14, 15, 7, 3, 1",
      "8, 4, 9, 2, 10, 5, 11, 1, 12, 6"
    ],
    "correct": 0
  },
  {
    "id": 10,
    "question": "Что будет выведено при прямом обходе дерева?",
    "options": ["a b c d e f", "a b d e c f", "d b e a f c", "b d e c f 1"],
    "correct": 1
  },
  {
    "id": 11,
    "question": "Укажите асимптотическую сложность операции удаления элемента в позиции i из массива размером n:",
    "options": ["O(n)", "O(logn)", "O(1)", "O(n^2)"],
    "correct": 0
  },
  {
    "id": 12,
    "question": "Высота (глубина) бинарного дерева поиска из N узлов в наилучшем случае определяется по формуле:",
    "options": ["h=log2(N+1)", "h=N", "h=log2(N+1)-1", "h=log2N"],
    "correct": 0
  },
  {
    "id": 13,
    "question": "В основе алгоритма Бойера-Мура-Хорспула используется:",
    "options": [
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Префикс-функция",
      "Эвристика \"хороших\" суффиксов",
      "Хеш-таблица"
    ],
    "correct": 0
  },
  {
    "id": 14,
    "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=О(g(n)):",
    "options": [
      "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно"
    ],
    "correct": 0
  },
  {
    "id": 15,
    "question": "Укажите асимптотическую сложность операции удаления элемента, на который имеется указатель (например, ptr), из двунаправленного списка размером n:",
    "options": ["O(n^2)", "O(logn)", "O(1)", "O(n)"],
    "correct": 2
  },
  {
    "id": 16,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска по бинарному дереву поиска (binary search tree, BST) в лучшем случае?",
    "options": ["f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(n log(n))", "f(n)=ϴ(log(n))"],
    "correct": 3
  },
  {
    "id": 17,
    "question": "Отличительная особенность алгоритма Бойера-Мура:",
    "options": [
      "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
      "Производится посимвольное сравнение образца с текстом при равенстве хешей",
      "Сравнение символов производится начиная с конца текста",
      "Сравнение символов производится начиная с конца образца;"
    ],
    "correct": 3
  },
  {
    "id": 18,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\nint count = 1;     \nwhile (count < n) {\n   count = count * 2;\n  / * Последовательность шагов программы с временной сложностью O (1) * /\n}",
    "options": ["квадратичная", "экспоненциальная", "линейная", "логарифмическая"],
    "correct": 3
  },
  {
    "id": 19,
    "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=Ω(g(n)) и сравнением двух действительных чисел а и b:",
    "options": ["а ≥ b", "а ≤ b", "а >b", "а = b"],
    "correct": 0
  },
  {
    "id": 20,
    "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов поиска:",
    "options": [
      "Операции сравнения данных",
      "Операции сравнения и перемещения данных",
      "Операции перемещения данных",
      "Все имеющиеся операции в алгоритме"
    ],
    "correct": 1
  },
  {
    "id": 21,
    "question": "Какой из видов линейных списков лучше использовать при реализации задачи по проверке баланса круглых скобок (соответствие открывающей и закрывающей скобок: (()()) – баланс)?",
    "options": ["Очередь", "Линейный двусвязный список", "Линейный односвязный список", "Стек"],
    "correct": 3
  },
  {
    "id": 22,
    "question": "Для структуры данных очередь справедливо:",
    "options": [
      "Удаление элемента возможно из начала и из конца списка",
      "Вставка нового элемента возможна в начало и в конец списка",
      "Доступ возможен к произвольному элементу",
      "Удаление элемента возможно с одной из сторон списка"
    ],
    "correct": 3
  },
  {
    "id": 23,
    "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=О(g(n)) и сравнением двух действительных чисел а и b:",
    "options": ["а = b", "а ≥ b", "а < b", "а ≤ b"],
    "correct": 3
  },
  {
    "id": 24,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\n   for(int i = 0; i < n; i++)\n      for(int j = 0; j < n; j++)\n           cout<<“hello”;",
    "options": ["константная", "экспоненциальная", "линейная", "квадратичная"],
    "correct": 3
  },
  {
    "id": 25,
    "question": "Выберите все характеристики хеш-функции, используемой в алгоритме поиска Рабина-Карпа:",
    "options": [
      "кольцевой (\"скользящий\", \"летящий\")",
      "полиномиальный хеш",
      "отсутствие коллизий",
      "модульная арифметика"
    ],
    "correct": 0
  },
  {
    "id": 26,
    "question": "Для структуры данных дек справедливо:",
    "options": [
      "Линейный список с произвольным количеством вершин",
      "Вставка нового элемента возможна только в начало списка",
      "Удаление элемента возможно из произвольной позиции",
      "Вставка нового элемента возможна в начало или в конец списка"
    ],
    "correct": 3
  },
  {
    "id": 27,
    "question": "Какой формулой определяется максимальное количество узлов в бинарном дереве высотой k (у корня высота 0)?",
    "options": ["2^k + 1", "2^(k-1) + 1", "2^k - 1", "2^(k+1) – 1"],
    "correct": 3
  },
  {
    "id": 28,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма бинарного (двоичного) поиска в худшем случае?",
    "options": ["f(n)=ϴ(n^2)", "f(n)=ϴ(log(n))", "f(n)=ϴ(n)", "f(n)=ϴ(n log(n))"],
    "correct": 1
  },
  {
    "id": 29,
    "question": "Перед выполнением какой операции в линейном двусвязном списке необходимо выполнить два \"подготовительных\" оператора:\n...\nq->prev->next=q->next;\nq->next->prev=q->prev;\n...\n(q - указатель на некрайний узел списка).",
    "options": [
      "Обмен значениями двух узлов по указателю q",
      "Вставка нового узла после элемента, ссылку на который хранит указатель q",
      "Удаление узла по указателю q",
      "Вставка нового узла по указателю q"
    ],
    "correct": 2
  },
  {
    "id": 30,
    "question": "Когда достигается максимальная эффективность алгоритма Бойера-Мура?",
    "options": [
      "Если образец длинный, а мощность алфавита достаточно низка",
      "Если образец длинный, а мощность алфавита достаточно велика",
      "Если образец короткий, а мощность алфавита достаточно низка",
      "Если образец короткий, а мощность алфавита достаточно велика"
    ],
    "correct": 1
  },
  {
    "id": 31,
    "question": "Укажите свойство, характеризующее структуру данных Дек:",
    "options": [
      "Удаление элемента возможно из заданной позиции",
      "Вставка нового элемента возможна в заданную позицию",
      "Обладает двумя первыми элементами",
      "Линейный список с заданным количеством узлов"
    ],
    "correct": 1
  },
  {
    "id": 32,
    "question": "В каком типе деревьев лист не должен содержать значение?",
    "options": ["В-дерево", "красно-черное дерево", "АВЛ-дерево", "бинарное дерево поиска"],
    "correct": 0
  },
  {
    "id": 33,
    "question": "Что измеряется для оценки временной (вычислительной) сложности алгоритма:",
    "options": [
      "Зависимость количества итераций от размера обрабатываемых данных",
      "Зависимость количества выполняемых основных операций от объёма входа",
      "Зависимость количества выполняемых основных операторов от размера доступной памяти",
      "Зависимость объема требуемой памяти от размера обрабатываемых данных"
    ],
    "correct": 1
  },
  {
    "id": 34,
    "question": "Временная (вычислительная) сложность алгоритма определяется объёмом входа n. Этот параметр в частном случае может определяться:",
    "options": [
      "Размером занимаемой входными данными памяти",
      "Количеством определённых подпрограмм",
      "Количеством основных операций",
      "Размером обрабатываемого массива или файла"
    ],
    "correct": 3
  },
  {
    "id": 35,
    "question": "Линейные списки находят применение в технологии:",
    "options": [
      "организации доменов Active Directory",
      "распределённых систем блокчейн",
      "символьной адресации узлов DNS",
      "реляционных баз данных"
    ],
    "correct": 1
  },
  {
    "id": 36,
    "question": "В основе алгоритма Кнута-Морриса-Пратта используется:",
    "options": [
      "Эвристика \"хороших\" суффиксов",
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Префикс-функция",
      "Хеш-таблица"
    ],
    "correct": 2
  },
  {
    "id": 37,
    "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=ϴ(g(n)):",
    "options": [
      "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)"
    ],
    "correct": 0
  },
  {
    "id": 38,
    "question": "Для каких узлов необходимо проверить коэффициент балансировки (баланс-фактор) после добавления узла в АВЛ-дерево?",
    "options": [
      "Для всех предков нового узла вплоть до корня дерева",
      "Только для нового добавленного узла",
      "Для всех узлов дерева",
      "Для родителя нового узла"
    ],
    "correct": 0
  },
  {
    "id": 39,
    "question": "Дисциплина обслуживания (порядок выполнения операций) стека:",
    "options": ["OFIL", "FIFO", "LOFI", "LIFO"],
    "correct": 3
  },
  {
    "id": 40,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Бойера-Мура в лучшем случае?",
    "options": [
      "f(n)=ϴ(n)",
      "f(n, m)=ϴ(log(n+m))",
      "f(n, m)=ϴ(log(n*m))",
      "f(n, m)=ϴ(log(n/m))"
    ],
    "correct": 3
  },
  {
    "id": 41,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма линейного (последовательного) поиска в худшем случае?",
    "options": ["f(n)=ϴ(n log(n))", "f(n)=ϴ(log(n))", "f(n)=ϴ(n2)", "f(n)=ϴ(n)"],
    "correct": 3
  },
  {
    "id": 42,
    "question": "Какие из перечисленных АВЛ-деревьев не требуют проведения перестройки?",
    "options": ["2, 3, 4", "1, 3, 4", "1, 2, 3", "1, 2, 4"],
    "correct": 3
  },
  {
    "id": 43,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма прямого поиска в тексте по образцу в худшем случае?",
    "options": ["f(n)=ϴ(n)", "f(n, m)=ϴ(log(n+m))", "f(n)=ϴ(n2)", "f(n, m)=ϴ(log(n*m))"],
    "correct": 2
  },
  {
    "id": 44,
    "question": "Когда один алгоритм считается эффективнее другого:",
    "options": [
      "Если его вычислительная сложность в наихудшем случае имеет более низкий порядок Роста",
      "Если его вычислительная сложность в наихудшем случае имеет более высокий порядок роста",
      "Если его вычислительная сложность в наилучшем случае имеет более низкий порядок роста",
      "Если его вычислительная сложность в наилучшем случае имеет более высокий порядок роста"
    ],
    "correct": 0
  },
  {
    "id": 45,
    "question": "При каком значении баланс-фактора b (т.е. разницы высот правого и левого поддеревьев) необходимо выполнить перестройку АВЛ-дерева?",
    "options": ["|b| = 0", "|b| = 2", "|b| = 1", "|b| > 2"],
    "correct": 1
  },
  {
    "id": 46,
    "question": "Какое из перечисленных АВЛ-деревьев требует балансировки?",
    "options": ["1", "3", "2", "4"],
    "correct": 1
  },
  {
    "id": 47,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма вставки ключа в бинарное дерево поиска в наилучшем случае?",
    "options": ["f(n)=О(n)", "f(n)=О(log(n))", "f(n)=О(1)", "f(n)=О(nlog(n))"],
    "correct": 1
  },
  {
    "id": 48,
    "question": "Зачем нужен заглавный элемент в двусвязном кольцевом списке?",
    "options": [
      "Чтобы иметь указатель на текущий элемент",
      "Чтобы указать на первый элемент",
      "Для связи последнего и первого элемента",
      "Для удаления пустых указателей"
    ],
    "correct": 1
  },
  {
    "id": 49,
    "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов сортировки:",
    "options": [
      "Все имеющиеся операции в алгоритме",
      "Операции перемещения данных",
      "Операции сравнения данных",
      "Операции сравнения и перемещения данных"
    ],
    "correct": 3
  },
  {
    "id": 50,
    "question": "Величина сдвига при поиске образца в тексте определяется наибольшим значением из трёх, вычисленных, соответственно, по трём правилам (эвристикам) в алгоритме:",
    "options": [
      "Бойера-Мура-Хорспула",
      "Кнута-Морриса-Прата",
      "Бойера-Мура с турбосдвигом",
      "Бойера-Мура"
    ],
    "correct": 3
  },
  {
    "id": 51,
    "question": "Суть алгоритма сортировки методом Шелла заключается в:",
    "options": [
      "Отдельной сортировке частей массива относительно опорного элемента",
      "Чередовании проходов по сортируемому массиву слева-направо и справа-налево",
      "Попарным сравнением элементов массива с целью выбора наименьшего",
      "Отдельной сортировке элементов, отстоящих друг от друга на расстоянии h, уменьшающемся на каждом проходе массива до значения 1"
    ],
    "correct": 3
  },
  {
    "id": 52,
    "question": "В чем смысл анализа алгоритма:",
    "options": [
      "Обеспечить безопасность данных",
      "Предсказать требуемые для его выполнения вычислительные ресурсы",
      "Определить требования к интерфейсу",
      "Предсказать форматы структур данных и внешние связи между ними"
    ],
    "correct": 1
  },
  {
    "id": 53,
    "question": "Алгоритмы сортировки выбором, обменом и вставкой называются простыми в смысле их:",
    "options": ["ёмкостной сложности", "временной сложности", "интеллектуальной сложности", "вычислительной сложности"],
    "correct": 2
  },
  {
    "id": 54,
    "question": "Что обеспечивает метод пробирования \"двойное хеширование\" при вставке элемента в хеш-таблицу, разрешающей коллизии по методу открытого адреса?",
    "options": [
      "Вычисление смещения, зависящее от значения ключа",
      "Эффективное рехеширование",
      "Вычисление смещения, не зависящее от значения ключа",
      "Длину первич"
    ],
    "correct": 0
  },
  {
    "id": 55,
    "question": "Известно, что при построении хеш-таблиц возможно появление коллизий. Коллизия это такая ситуация, когда:",
    "options": [
      "Определение области поиска производится с помощью учета знака разности между ключом и текущим значением элемента",
      "Для разных ключей хэш-функция может принимать одно и тоже значение h(ki) = h(kj)",
      "Способ нахождения промежуточных значений определяется величиной по имеющемуся дискретному набору значений",
      "Для одинаковых ключей хэш-функция может принимать разные значения h(ki) ≠ h(kj)"
    ],
    "correct": 1
  },
  {
    "id": 56,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма Дейкстры в графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E – количество ребер:",
    "options": ["f(n)=О(V)", "f(n)=О(E*log(V))", "f(n)=О(E)", "f(n)=О(V^2)"],
    "correct": 1
  },
  {
    "id": 57,
    "question": "Какая функция реализует линейную рекурсию:",
    "options": [
      "Содержит один вызов самой себя",
      "Содержит линейную функцию",
      "Количество вызовов самой себя определяется линейной функцией",
      "Содержит"
    ],
    "correct": 0
  },
  {
    "id": 58,
    "question": "Какой код будет получен из входной строки символов ABCCCDDDDD при использовании алгоритма Хаффмана?",
    "options": [
      "110 111 10 10 10 0 0 0 0 0 0",
      "1 2 3 3 3 4 4 4 4 4",
      "A1 B1 C3 D5",
      "00 01 10 10 10 11 11 11 11 11"
    ],
    "correct": 0
  },
  {
    "id": 59,
    "question": "Какая идея положена в основу построения алгоритма методом \"жадного алгоритма\"",
    "options": [
      "Осуществляется разбиение задачи на неперекрывающиеся подзадачи",
      "На каждом этапе осуществляется выбор решения, которое может не быть оптимальным в данный момент, но в результате решение станет оптимальным",
      "Осуществляется разбиение задачи на перекрывающиеся подзадачи",
      "На каждом этапе осуществляется выбор решения, которое кажется оптимальным в данный момент"
    ],
    "correct": 3
  },
  {
    "id": 60,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 44, 11, 7, 8, 42. Какова высота этого дерева?",
    "options": ["4", "3", "5", "2"],
    "correct": 0
  },
  {
    "id": 61,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов\n(1,3,5,2,4), (1,3,5,2,4), (1,3,2,5,4), (1,3,2,4,5),\n(1,3,2,4,5), (1,2,3,4,5), (1,2,3,4,5), (1,2,3,4,5)",
    "options": ["Простой вставки", "Простого выбора", "Простого обмена", "Шелла"],
    "correct": 2
  },
  {
    "id": 62,
    "question": "Что будет результатом применения алгоритма RLE (\"групповое кодирование\") к сжатию текста ААААААААААААААААААAВВВВВАААВВВВВBBС?",
    "options": [
      "(22)A(12)B(1)C",
      "ABАВC(19,5,3,7,1)",
      "19A5B3A7B1C",
      "ABC(19,5,3,7,1)"
    ],
    "correct": 2
  },
  {
    "id": 63,
    "question": "Нелинейными называются структуры данных, в которых:",
    "options": [
      "связи между элементами не зависят от упорядоченности значений элементов",
      "связи между элементами не зависят от линейной упорядоченности элементов",
      "связи между элементами зависят от выполнения определенного условия",
      "связи между элементами не зависят от выполнения какого-либо условия"
    ],
    "correct": 1
  },
  {
    "id": 64,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов\n(3,1,4,2,5), (3,1,2,4,5), (2,1,3,4,5), (1,2,3,4,5)",
    "options": ["Простого обмена", "Простой вставки", "Шелла", "Простого выбора"],
    "correct": 3
  },
  {
    "id": 65,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в ширину в неориентированном графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E –количество ребер:",
    "options": ["f(n)=О(V2)", "f(n)=О(V log(E))", "f(n)=О(V+E)", "f(n)=О(V)"],
    "correct": 2
  },
  {
    "id": 66,
    "question": "Какой код будет получен из входной строки символов 1111223444 при использовании алгоритма группового кодирования RLE (Run Length Encoding)?",
    "options": [
      "0 0 0 0 01 01 10 11 11 11",
      "1-4-2-2-3-1-4-3",
      "41 22 13 34",
      "4 1 2 2 1 3 3 4"
    ],
    "correct": 3
  },
  {
    "id": 67,
    "question": "К недостаткам рекурсивного метода можно отнести:",
    "options": [
      "возможность переполнения стековой памяти программного процесса",
      "расход времени на выделение и очистку стекового кадра в памяти",
      "меньшая точность результата вычислений",
      "возможность переполнения динамически распределяемой памяти программного процесса"
    ],
    "correct": 0
  },
  {
    "id": 68,
    "question": "В теории вычислимости важную роль играет функция Аккермана A(m, n), определённая следующим образом: Вычислите значение A(2, 2). (Введите только число)",
    "options": ["7", "5", "6", "8"],
    "correct": 0
  },
  {
    "id": 69,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в среднем и наилучшем случаях?",
    "options": ["f(n)=ϴ(log(n))", "f(n)=ϴ(n log(n))", "f(n)=ϴ(n^2)", "f(n)=ϴ(n)"],
    "correct": 1
  },
  {
    "id": 70,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\n   for(int i = n/2; i < n; i++)\n      for(int j = 1; j < n; j = j*2) {\n       /* Последовательность шагов программы с временной сложностью O(1) */\n      }",
    "options": ["логарифмическая", "квадратичная", "линейная", "линейно-логарифмическая"],
    "correct": 3
  },
  {
    "id": 71,
    "question": "Сложность рекурсивного алгоритма вычисления N-ого числа Фибоначчи можно снизить с O(2^n) до О(n), т.е. оптимизировать процесс вычисления, если сохранять промежуточные значения решения подзадач. Какой метод построения алгоритма (алгоритмическая стратегия) здесь задействован?",
    "options": [
      "Динамическое программирование",
      "Метод рекурсии",
      "Разделяй и властвуй",
      "\"Жадный\" ал"
    ],
    "correct": 0
  },
  {
    "id": 72,
    "question": "Как определить, что функция реализует каскадную (множественную) рекурсию:",
    "options": [
      "Функция вызывает несколько внешних функций по любой из всех возможных ветвей алгоритма",
      "Функция вызывает последовательно несколько внешних функций",
      "Функция вызывает параллельно несколько внешних функций",
      "Вызов функции по любой из всех возможных ветвей алгоритма встречается более одного раза"
    ],
    "correct": 3
  },
  {
    "id": 73,
    "question": "Имеется линейный односвязный список из n (n>2) узлов. Структура узла списка:\nstruct Tnode {\n    Tdata data;\n    Tnode* next;\n}\nL - указатель на его начало. Укажите группу операторов, которые обеспечат корректное удаление двух узлов из начала списка L:",
    "options": [
      "q1=L; delete q1; q2=q1; L=q2->next; delete q2;",
      "q1=L; L=L->next->next; q2=L; delete q1; delete q2;",
      "q1=L; q2=L; L=q2->next; delete q1;delete q2;",
      "q1=L; q2=L->next; L=L->next->next; delete q1;delete q2;"
    ],
    "correct": 3
  },
  {
    "id": 74,
    "question": "Что проверяет условие Айверсона в алгоритме сортировки методом простого обмена:",
    "options": [
      "Количество элементов в неупорядоченной части массива",
      "Не пуст ли массив",
      "Наличие обменов в текущем проходе по массиву",
      "Наличие сравнений в тек"
    ],
    "correct": 2
  },
  {
    "id": 75,
    "question": "В результате применения алгоритма RLE был получен сжатый текст 9A-4ВCAВ7C. Какой текст был сжат этим алгоритмом?",
    "options": [
      "AAAAAAAAABACBCCCCCCC",
      "(9)A-BCAB(7)C",
      "AAAAAAAAABCABCCCCCCC",
      "AAAAAAAAABCABBCABBCABBCABCCCCCCC"
    ],
    "correct": 2
  },
  {
    "id": 76,
    "question": "Префиксный код в теории кодирования - это:",
    "options": [
      "кодовое слово фиксированной длины, с которого может начинаться другое кодовое слово",
      "кодовое слово переменной длины, с которого может начинаться другое кодовое слово",
      "кодовое слово фиксированной длины, с которого не может начинаться другое кодовое слово",
      "кодовое слово переменной длины, с которого не может начинаться другое кодовое слово того же кода"
    ],
    "correct": 3
  },
  {
    "id": 77,
    "question": "Когда алгоритм считается корректным:",
    "options": [
      "Когда для каждого ввода результатом его работы является корректный вывод",
      "Когда для каждого вывода результатом его работы является корректный ввод",
      "Когда для одного определённого ввода результатом его работы является корректный вывод",
      "Когда он может выдать ответ, отличный от ожидаемого"
    ],
    "correct": 0
  },
  {
    "id": 78,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом Шелла в наилучшем случае?",
    "options": ["f(n)=О(n)", "f(n)=О(n^2)", "f(n)=О(n log(n))", "f(n)=О(log(n))"],
    "correct": 0
  },
  {
    "id": 79,
    "question": "Алгоритм Флойда-Уоршала - это:",
    "options": [
      "Алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе",
      "Алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных",
      "Алгоритм поиска заданного пользователем количества путей между двумя вершинами во взвешенном графе",
      "Алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа"
    ],
    "correct": 3
  },
  {
    "id": 80,
    "question": "Что предусматривает метод динамического программирования?",
    "options": [
      "Переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач",
      "Запоминание результатов решения тех подзадач, которые могут повторно Использоваться",
      "Получение решения исходно задачи путем комбинирования рекурсивных решений подзадач",
      "Выбор локально-оптимального решения каждой подзадачи для достижения оптимального конечного результата"
    ],
    "correct": 1
  },
  {
    "id": 81,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простой вставки в наилучшем случае:",
    "options": ["f(n)=О(n)", "f(n)=О(log(n))", "f(n)=О(n log(n))", "f(n)=О(n^2)"],
    "correct": 0
  },
  {
    "id": 82,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 15, 18, 10, 11, 7, 8, 17, 16. Из дерева удалили узел с ключом 18. Узел с каким значением был выбран замещающим?",
    "options": ["18", "16", "15", "17"],
    "correct": 3
  },
  {
    "id": 83,
    "question": "Как называется алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных?",
    "options": ["Алгоритм Крускала", "Алгоритм Дейкстры", "Алгоритм Йена", "Алгоритм Флойда-Уоршала"],
    "correct": 1
  },
  {
    "id": 84,
    "question": "Чем может быть вызвано переполнение стека при выполнении рекурсивной функции с небольшой глубиной рекурсии:",
    "options": [
      "Неправильно оформленным выводом результата",
      "Неправильно сформулированным условием завершения рекурсии",
      "Неправильным выполнением вызова функции",
      "Неправильно оформленным блоком входа в рекурсию"
    ],
    "correct": 1
  },
  {
    "id": 85,
    "question": "Что определяет структура данных:",
    "options": [
      "Множество данных",
      "Множество данных и отношений между ними",
      "Множество данных и множество операций над ними",
      "Множество отношений между данными в форме операций над ними"
    ],
    "correct": 2
  },
  {
    "id": 86,
    "question": "Дано описание функции:\nint f(int x) { return (x == 0) ? 1 : x * f(x-1); }\nДанная функция вычисляет:",
    "options": ["факториал числа n", "n-ое простое число", "n-ое число Фибоначчи", "степень числа n"],
    "correct": 0
  },
  {
    "id": 87,
    "question": "Алгоритм обхода графа - это:",
    "options": [
      "Алгоритм, указывающий несколько путей обработки одних и тех же входных данных, без какого-либо уточнения, какой именно вариант будет выбран",
      "Алгоритм, устанавливающий переход от одной его вершины к другой с целью нахождения кратчайшего пути",
      "Алгоритм, устанавливающий переход от одной его вершины к другой в поисках свойств связей этих вершин",
      "Алгоритм, устанавливающий движение от начальной вершины в определенном направлении (по определенному пути) до тех пор, пока не будет достигнут конец пути или заданная вершина"
    ],
    "correct": 3
  },
  {
    "id": 88,
    "question": "Структура хранения, обеспечивающая прямой доступ к каждому элементу данных, т.е. время доступа к значению О(1):",
    "options": ["сетевая", "иерархическая", "списочная", "векторная"],
    "correct": 3
  },
  {
    "id": 89,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 11, 7, 8, 44, 42. В это дерево был вставлен узел с ключом 6. В какое поддерево и какого узла был вставлен узел?",
    "options": [
      "В левое поддерево узла 11",
      "В левое поддерево узла 7",
      "В левое поддерево узла 13",
      "В левое поддерево узла 42"
    ],
    "correct": 1
  },
  {
    "id": 90,
    "question": "Имеется следующее оптимальное кодовое дерево (ОКД):\nВыберите исходную строку, которая была закодирована в битовый код 111 0 0 10 10 0 110 0 10 0 по алгоритму Хаффмана с использованием приведенного ОКД:",
    "options": ["DDDDDCCCBA", "BDDCCDADCD", "ABDCDCDCDD", "ABCCCDD"],
    "correct": 1
  },
  {
    "id": 91,
    "question": "Как называется алгоритм, который напрямую или через другие вспомогательные алгоритмы вызывает сам себя:",
    "options": ["Разветвляющийся", "Циклический", "Рекурсивный", "Линейный"],
    "correct": 2
  },
  {
    "id": 92,
    "question": "Росту первичного кластера в хеш-таблице с открытым адресом способствует:",
    "options": [
      "Смещение и размер таблицы имеют общие множители",
      "Размер таблицы определен как простое число и смещение простое число",
      "Для большого количества ключей хеш-функция сформировала один и тот же индекс",
      "Ключи равномерно распределены по та"
    ],
    "correct": 0
  },
  {
    "id": 93,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простого обмена (с условием Айверсона) в наилучшем случае:",
    "options": ["f(n)=О(n log(n))", "f(n)=О(log(n))", "f(n)=О(n)", "f(n)=О(n^2)"],
    "correct": 2
  },
  {
    "id": 94,
    "question": "К графу на рисунке 1 применен алгоритм обхода в глубину. Какое из остовных деревьев соответствует обходу в глубину с вершины 3?",
    "options": ["2", "5", "3", "4"],
    "correct": 3
  },
  {
    "id": 95,
    "question": "Что помещается в стек рекурсивных вызовов при вызове рекурсивной функции?",
    "options": [
      "Значения всех переменных функции при текущем вызове для возврата в точку вызова",
      "Описание всех переменных функции при текущем вызове",
      "Имена локальных переменных и параметров функции",
      "Адрес точки возврата, значения всех переменных функции текущего вызова"
    ],
    "correct": 3
  },
  {
    "id": 96,
    "question": "Чему равна сумма степеней вершин графа?",
    "options": [
      "Числу его ребер",
      "Удвоенному числу его ребер",
      "Сумме веса ребер",
      "Удвоенному весу ребер"
    ],
    "correct": 1
  },
  {
    "id": 97,
    "question": "Имеется бинарное дерево поиска, содержащее целые числа от 1 до 7. Каким будет результат вывода при обратном обходе дерева (postoder):",
    "options": [
      "4, 1, 2, 3, 5, 6, 7",
      "1, 2, 3, 4, 5, 6, 7",
      "4, 1, 5, 2, 6, 3, 7",
      "7, 6, 5, 4, 3, 2, 1"
    ],
    "correct": 3
  },
  {
    "id": 98,
    "question": "Каков главный недостаток хеш-таблиц?",
    "options": [
      "В отказе на повторное хеширование",
      "В трудоёмкой функции хеширования",
      "Фиксированный размер, при неизвестном окончательном числе элементов",
      "Фиксированное число эл"
    ],
    "correct": 2
  },
  {
    "id": 99,
    "question": "Выберите код, являющийся результатом сжатия по методу скользящего окна текста \"abacabacabadaca\". Примечание: кавычки ограничивают текст и не кодируются.",
    "options": [
      "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(2,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(4,4,d)(2,1,c)(2,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(4,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(3,7,d("
    ],
    "correct": 0
  },
  {
    "id": 100,
    "question": "Диапазон допустимых значений простого типа данных определяется разрядностью отдельного значения этого типа. В перечне примеров найдите неправильный вариант:",
    "options": [
      "char – занимает 1 байт, следовательно, имеет диапазон от –128 до +127",
      "short int – занимает 2 байта, следовательно, имеет диапазон от –32 768 до +32 767",
      "long int – занимает 4 байта, следовательно, имеет диапазон от –2 147 483 648 до +2 147 483 647",
      "int – занимает 4 байта, следовательно, имеет диапазон от –2 148 483 647 до +2 147 483 647"
    ],
    "correct": 3
  },
  {
    "id": 101,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки шейкерным методом (с условием Айверсона) в наихудшем случае:",
    "options": ["f(n)=О(log(n))", "f(n)=О(n^2)", "f(n)=О(n log(n))", "f(n)=О(n^3)"],
    "correct": 1
  },
  {
    "id": 102,
    "question": "Какой алгоритм из перечисленных не основан на жадном подходе?",
    "options": [
      "Алгоритм нахождения кратчайшего пути Беллмана-Форда",
      "Алгоритм нахождения кратчайшего пути Дейкстры",
      "Алгоритм кодирования Хаффмана",
      "Алгоритм построения минимального остовного дерева Крускала"
    ],
    "correct": 0
  },
  {
    "id": 103,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки слиянием (Mergesort) в среднем и наихудшем случаях:",
    "options": ["f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(log(n))", "f(n)=ϴ(n log(n))"],
    "correct": 3
  },
  {
    "id": 104,
    "question": "Что хранит матрица смежности графа?",
    "options": [
      "Список ребер и их направление",
      "Список вершин",
      "Длину пути между вершинами графа",
      "Только направления"
    ],
    "correct": 0
  },
  {
    "id": 105,
    "question": "Система байтового кодирования символов ASCII кодирует символы входной последовательности кодами:",
    "options": [
      "переменной длины до одного байта",
      "фиксированной длины в один байт",
      "хеш-кодами",
      "переменной длины свыше одного байта"
    ],
    "correct": 1
  },
  {
    "id": 106,
    "question": "Для динамической структуры данных (переменной) справедливо утверждение:",
    "options": [
      "создается на этапе компиляции кода и размер не может быть изменен во время выполнения программы",
      "создается на этапе выполнения программы и размер может быть изменен на этапе выполнения",
      "создается на этапе компиляции кода и размер может быть изменен во время выполнения программы",
      "создается на этапе выполнения программы и размер не может быть изменен на этапе выполнения"
    ],
    "correct": 1
  },
  {
    "id": 107,
    "question": "Как называется алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа?",
    "options": ["Алгоритм Флойда-Уоршала", "Алгоритм Дейкстры", "Алгоритм Крускала", "Алгоритм Прима"],
    "correct": 0
  },
  {
    "id": 108,
    "question": "Дана следующая рекурсивная функция:\nint fib(int n) {\nif (n <2) { return 1; }\nelse { return fib(n - 2) + fib(n - 1); }\n}\nКакова высота дерева рекурсии при вызове fib(5)",
    "options": ["7", "4", "3", "5"],
    "correct": 0
  },
  {
    "id": 109,
    "question": "Метод сортировки считается устойчивым, если:",
    "options": [
      "время доступа к значению константное",
      "относительное расположение элементов с равными ключами всегда изменяется",
      "начальная отсортированность массива не важна",
      "относительное расположение элементов с равными ключами не изменяется"
    ],
    "correct": 3
  },
  {
    "id": 110,
    "question": "Свойство алгоритма, обеспечивающее возможность его использования для решения множества однотипных задач (применимость к различным наборам входных данных), называется:",
    "options": ["Массовость", "Результативность", "Дискретность", "Завершаемость"],
    "correct": 0
  },
  {
    "id": 111,
    "question": "Какой алгоритм сортировки из перечисленных ниже будет самым эффективным на уже отсортированном массиве?",
    "options": ["Вставками", "пирамидальная", "быстрая сортировка", "слиянием"],
    "correct": 0
  },
  {
    "id": 112,
    "question": "Что будет результатом применения алгоритма RLE - \"Групповое кодирование\" к сжатию текста ААААААААААААААААААВCAВCAСCCCCC?",
    "options": [
      "A(18)BCA(2)C(6)",
      "18A-6ВCAВCA6C",
      "18A-2BCA6C",
      "A18ABCABC6C"
    ],
    "correct": 0
  },
  {
    "id": 113,
    "question": "Понятие \"глубина рекурсии\" для рекурсивной функции определяет:",
    "options": [
      "Наибольшее одновременное количество рекурсивных обращений функции",
      "Количество операторов вызова функции в самой функции",
      "Наибольшее количество операторов в рекурсивной функции",
      "Количество внешних вызовов функции в программе"
    ],
    "correct": 0
  },
  {
    "id": 114,
    "question": "Какой алгоритм реализует стратегию \"разделяй и властвуй\" (divide and conquer approach)?",
    "options": [
      "алгоритм Дейкстры",
      "алгоритм Бойера-Мура",
      "алгоритм быстрой сортировки Quick-sort",
      "алгоритм Крускала"
    ],
    "correct": 2
  },
  {
    "id": 115,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма пирамидальной сортировки (Heapsort) в среднем случае?",
    "options": ["f(n)=О(n log(n))", "f(n)=О(n)", "f(n)=О(n^2)", "f(n)=О(log(n))"],
    "correct": 0
  },
  {
    "id": 116,
    "question": "Есть ли ошибка в коде функции f, которая осуществляет получение ссылки на последний узел линейного односвязного списка со структурой узла? struct Tnode{ Tdata data; Tnode* next;}; Tnode *f(Tnode *L) {     Tnode *q=L;     while(q) { q=q->next; }     return q; }",
    "options": [
      "Ошибка в записи оператора q=q->next",
      "Ошибки нет",
      "Ошибка в условии while (q) - должно быть while (q->next)",
      "Ошибка в записи оператора Tnode *q=L - должно быть Tnode q=L"
    ],
    "correct": 2
  },
  {
    "id": 117,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов (1,3,5,2,4), (1,3,5,2,4), (1,2,3,5,4), (1,2,3,4,5)",
    "options": ["Простой вставки", "Простого выбора", "Пирамидальная", "Простого обмена"],
    "correct": 0
  },
  {
    "id": 118,
    "question": "Прямой доступ к элементу данных в памяти делает возможным:",
    "options": [
      "порядковый номер элемента в структуре",
      "идентификатор элемента в программе",
      "любая списочная структура",
      "адрес элемента в ОЗУ"
    ],
    "correct": 3
  },
  {
    "id": 119,
    "question": "Какая структура данных используется для хранения элементов данных в хеш-таблице, при реализации разрешения коллизий по методу цепочек (цепного хеширования)?",
    "options": ["Дек", "Однонаправленный список", "Двоичное дерево", "Очередь"],
    "correct": 1
  },
  {
    "id": 120,
    "question": "Исходный текст \"abcdabcdaaacc\" был сжат, в результате был получен код abcd(4,4)(8,1)(1,1)(1,1) (5,1). Какой принцип сжатия текстовой информации при этом использовался?",
    "options": [
      "уменьшение объема текста за счет формирования словаря кодов цепочек и замены цепочек на код",
      "частотное кодирование",
      "уменьшение объема текста за счет замены каждой повторно встреченной цепочки символов комбинацией: (количество знаков в цепочке, цепочка символов)",
      "уменьшение объема текста за счет замены повторно встретившейся цепочки символов ссылкой на ранее встреченную цепочку"
    ],
    "correct": 3
  },
  {
    "id": 121,
    "question": "Какая проблема может возникнуть в хеш-таблице с открытым адресом, после удаления ключа из первичного кластера ключей, хешированных с одним индексом?",
    "options": [
      "Невозможность найти ключ в первичном кластере",
      "Ключи поменяют индексы, с которыми были хешированы при вставке в таблицу",
      "Неоднозначность результата поиска ключа",
      "Невозможно вставить ключ в первичный кластер"
    ],
    "correct": 0
  },
  {
    "id": 122,
    "question": "Что делает следующая функция? int trinity (int a, int b, int c) {    if ((a >= b) && (c= b) return trinity (a,c,b);    else return trinity (b,a,c); }",
    "options": [
      "ничего из перечисленного",
      "вычисляет минимальное значение",
      "вычисляет максимальное значение",
      "вычисляет среднее значение"
    ],
    "correct": 3
  },
  {
    "id": 123,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в наихудшем случае:",
    "options": ["f(n)=О(n^2)", "f(n)=О(log(n))", "f(n)=О(n log(n))", "f(n)=О(n^3)"],
    "correct": 0
  },
  {
    "id": 124,
    "question": "Каков максимальный размер кодового слова, полученного алгоритмом Шеннона-Фано, для текста, частота появления символов в котором определяется таблицей: а-11,и-8,пробел - 6, л-4, п-3, с-3, м-2, ы-2, н-1, ш-1, ч-1, к-1, у-1, т-1, ь-1?",
    "options": ["6", "5", "7", "4"],
    "correct": 0
  }
];

    // Перемешиваем ответы для каждого вопроса
    const shuffledQuestions = quizData.map(q => shuffleQuestionOptions(q));
    setQuestions(shuffledQuestions);
  }, []);

  const handleAnswer = (index) => {
    if (answeredQuestions.has(currentQuestion)) return;
    setSelectedAnswer(index);
    setShowResult(true);
    if (index === questions[currentQuestion].correct) {
      setScore(score + 1);
    }
    setAnsweredQuestions(new Set([...answeredQuestions, currentQuestion]));
  };

  const nextQuestion = () => {
    if (currentQuestion < questions.length - 1) {
      setCurrentQuestion(currentQuestion + 1);
      setSelectedAnswer(null);
      setShowResult(false);
    }
  };

  const prevQuestion = () => {
    if (currentQuestion > 0) {
      setCurrentQuestion(currentQuestion - 1);
      setSelectedAnswer(null);
      setShowResult(false);
    }
  };

  const resetQuiz = () => {
    setCurrentQuestion(0);
    setSelectedAnswer(null);
    setShowResult(false);
    setScore(0);
    setAnsweredQuestions(new Set());
    // При сбросе — снова перемешиваем!
    const quizData = [
  {
    "id": 1,
    "question": "Какая структура данных относятся к категории линейных списков?",
    "options": ["Множество", "Бинарное дерево", "Дек", "Массив"],
    "correct": 2
  },
  {
    "id": 2,
    "question": "Какие нотации можно использовать для асимптотической оценки сложности алгоритма в лучшем случае?",
    "options": ["нотация о (о-малое)", "нотация Ω (омега-большое)", "нотация Θ (тета)", "нотация О (о-большое)"],
    "correct": 1
  },
  {
    "id": 3,
    "question": "Бинарное дерево - это:",
    "options": [
      "дерево, у которого каждый узел содержит до двух различных значений",
      "дерево, элементы которого являются двоичными числами",
      "дерево, у которого каждый узел может содержать до двух дочерних узлов",
      "дерево, у которого каждый узел должен содержать два дочерних узла"
    ],
    "correct": 2
  },
  {
    "id": 4,
    "question": "Отличительная особенность алгоритма Бойера-Мура-Хорспула:",
    "options": [
      "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с таблицей префиксов (префикс-функцией)",
      "После каждого неудачного сравнения производится сдвиг образца вправо на количество позиций, равное количеству предшествующих удачных сравнений",
      "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
      "После каждого неудачного сравнения производится сдвиг образца вправо в соответствии с эвристикой стоп-символов (\"плохих\" символов)"
    ],
    "correct": 3
  },
  {
    "id": 5,
    "question": "Какое из условий проверяется при определении сбалансированности красно-черного дерева?",
    "options": [
      "Количество красных или черных узлов в левом и правом поддеревьях равны",
      "Высота левого и правого поддерева равны",
      "Любой путь от корня дерева к листу содержит одно и то же число черных узлов",
      "Любой путь от корня дерева к листу содержит одно и то же число красных узлов"
    ],
    "correct": 2
  },
  {
    "id": 6,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска хешированием в худшем случае?",
    "options": ["f(n)=ϴ(log(n))", "f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(1)"],
    "correct": 1
  },
  {
    "id": 7,
    "question": "Какие отношения между элементами поддерживает структура данных бинарное дерево?",
    "options": ["Двоичные", "Иерархические", "Сложные", "Бинарные"],
    "correct": 1
  },
  {
    "id": 8,
    "question": "В основе алгоритма Рабина-Карпа используется:",
    "options": [
      "Префикс-функция",
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Эвристика \"хороших\" суффиксов",
      "Хеш-функция"
    ],
    "correct": 3
  },
  {
    "id": 9,
    "question": "В какой последовательности располагаются вершины дерева при прямом обходе (preorder):",
    "options": [
      "1, 2, 4, 8, 9, 5, 10, 11, 3, 6, 12, 13, 7, 14, 15",
      "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15",
      "8, 9, 4, 10, 11, 5, 2, 12, 13, 6, 14, 15, 7, 3, 1",
      "8, 4, 9, 2, 10, 5, 11, 1, 12, 6"
    ],
    "correct": 0
  },
  {
    "id": 10,
    "question": "Что будет выведено при прямом обходе дерева?",
    "options": ["a b c d e f", "a b d e c f", "d b e a f c", "b d e c f 1"],
    "correct": 1
  },
  {
    "id": 11,
    "question": "Укажите асимптотическую сложность операции удаления элемента в позиции i из массива размером n:",
    "options": ["O(n)", "O(logn)", "O(1)", "O(n^2)"],
    "correct": 0
  },
  {
    "id": 12,
    "question": "Высота (глубина) бинарного дерева поиска из N узлов в наилучшем случае определяется по формуле:",
    "options": ["h=log2(N+1)", "h=N", "h=log2(N+1)-1", "h=log2N"],
    "correct": 0
  },
  {
    "id": 13,
    "question": "В основе алгоритма Бойера-Мура-Хорспула используется:",
    "options": [
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Префикс-функция",
      "Эвристика \"хороших\" суффиксов",
      "Хеш-таблица"
    ],
    "correct": 0
  },
  {
    "id": 14,
    "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=О(g(n)):",
    "options": [
      "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно"
    ],
    "correct": 0
  },
  {
    "id": 15,
    "question": "Укажите асимптотическую сложность операции удаления элемента, на который имеется указатель (например, ptr), из двунаправленного списка размером n:",
    "options": ["O(n^2)", "O(logn)", "O(1)", "O(n)"],
    "correct": 2
  },
  {
    "id": 16,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска по бинарному дереву поиска (binary search tree, BST) в лучшем случае?",
    "options": ["f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(n log(n))", "f(n)=ϴ(log(n))"],
    "correct": 3
  },
  {
    "id": 17,
    "question": "Отличительная особенность алгоритма Бойера-Мура:",
    "options": [
      "После каждого неудачного сравнения производится сдвиг образца вправо на одну позицию",
      "Производится посимвольное сравнение образца с текстом при равенстве хешей",
      "Сравнение символов производится начиная с конца текста",
      "Сравнение символов производится начиная с конца образца;"
    ],
    "correct": 3
  },
  {
    "id": 18,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\nint count = 1;     \nwhile (count < n) {\n   count = count * 2;\n  / * Последовательность шагов программы с временной сложностью O (1) * /\n}",
    "options": ["квадратичная", "экспоненциальная", "линейная", "логарифмическая"],
    "correct": 3
  },
  {
    "id": 19,
    "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=Ω(g(n)) и сравнением двух действительных чисел а и b:",
    "options": ["а ≥ b", "а ≤ b", "а >b", "а = b"],
    "correct": 0
  },
  {
    "id": 20,
    "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов поиска:",
    "options": [
      "Операции сравнения данных",
      "Операции сравнения и перемещения данных",
      "Операции перемещения данных",
      "Все имеющиеся операции в алгоритме"
    ],
    "correct": 1
  },
  {
    "id": 21,
    "question": "Какой из видов линейных списков лучше использовать при реализации задачи по проверке баланса круглых скобок (соответствие открывающей и закрывающей скобок: (()()) – баланс)?",
    "options": ["Очередь", "Линейный двусвязный список", "Линейный односвязный список", "Стек"],
    "correct": 3
  },
  {
    "id": 22,
    "question": "Для структуры данных очередь справедливо:",
    "options": [
      "Удаление элемента возможно из начала и из конца списка",
      "Вставка нового элемента возможна в начало и в конец списка",
      "Доступ возможен к произвольному элементу",
      "Удаление элемента возможно с одной из сторон списка"
    ],
    "correct": 3
  },
  {
    "id": 23,
    "question": "Укажите правильную аналогию между асимптотическим сравнением двух функций f и g для обозначения f(n)=О(g(n)) и сравнением двух действительных чисел а и b:",
    "options": ["а = b", "а ≥ b", "а < b", "а ≤ b"],
    "correct": 3
  },
  {
    "id": 24,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\n   for(int i = 0; i < n; i++)\n      for(int j = 0; j < n; j++)\n           cout<<“hello”;",
    "options": ["константная", "экспоненциальная", "линейная", "квадратичная"],
    "correct": 3
  },
  {
    "id": 25,
    "question": "Выберите все характеристики хеш-функции, используемой в алгоритме поиска Рабина-Карпа:",
    "options": [
      "кольцевой (\"скользящий\", \"летящий\")",
      "полиномиальный хеш",
      "отсутствие коллизий",
      "модульная арифметика"
    ],
    "correct": 0
  },
  {
    "id": 26,
    "question": "Для структуры данных дек справедливо:",
    "options": [
      "Линейный список с произвольным количеством вершин",
      "Вставка нового элемента возможна только в начало списка",
      "Удаление элемента возможно из произвольной позиции",
      "Вставка нового элемента возможна в начало или в конец списка"
    ],
    "correct": 3
  },
  {
    "id": 27,
    "question": "Какой формулой определяется максимальное количество узлов в бинарном дереве высотой k (у корня высота 0)?",
    "options": ["2^k + 1", "2^(k-1) + 1", "2^k - 1", "2^(k+1) – 1"],
    "correct": 3
  },
  {
    "id": 28,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма бинарного (двоичного) поиска в худшем случае?",
    "options": ["f(n)=ϴ(n^2)", "f(n)=ϴ(log(n))", "f(n)=ϴ(n)", "f(n)=ϴ(n log(n))"],
    "correct": 1
  },
  {
    "id": 29,
    "question": "Перед выполнением какой операции в линейном двусвязном списке необходимо выполнить два \"подготовительных\" оператора:\n...\nq->prev->next=q->next;\nq->next->prev=q->prev;\n...\n(q - указатель на некрайний узел списка).",
    "options": [
      "Обмен значениями двух узлов по указателю q",
      "Вставка нового узла после элемента, ссылку на который хранит указатель q",
      "Удаление узла по указателю q",
      "Вставка нового узла по указателю q"
    ],
    "correct": 2
  },
  {
    "id": 30,
    "question": "Когда достигается максимальная эффективность алгоритма Бойера-Мура?",
    "options": [
      "Если образец длинный, а мощность алфавита достаточно низка",
      "Если образец длинный, а мощность алфавита достаточно велика",
      "Если образец короткий, а мощность алфавита достаточно низка",
      "Если образец короткий, а мощность алфавита достаточно велика"
    ],
    "correct": 1
  },
  {
    "id": 31,
    "question": "Укажите свойство, характеризующее структуру данных Дек:",
    "options": [
      "Удаление элемента возможно из заданной позиции",
      "Вставка нового элемента возможна в заданную позицию",
      "Обладает двумя первыми элементами",
      "Линейный список с заданным количеством узлов"
    ],
    "correct": 1
  },
  {
    "id": 32,
    "question": "В каком типе деревьев лист не должен содержать значение?",
    "options": ["В-дерево", "красно-черное дерево", "АВЛ-дерево", "бинарное дерево поиска"],
    "correct": 0
  },
  {
    "id": 33,
    "question": "Что измеряется для оценки временной (вычислительной) сложности алгоритма:",
    "options": [
      "Зависимость количества итераций от размера обрабатываемых данных",
      "Зависимость количества выполняемых основных операций от объёма входа",
      "Зависимость количества выполняемых основных операторов от размера доступной памяти",
      "Зависимость объема требуемой памяти от размера обрабатываемых данных"
    ],
    "correct": 1
  },
  {
    "id": 34,
    "question": "Временная (вычислительная) сложность алгоритма определяется объёмом входа n. Этот параметр в частном случае может определяться:",
    "options": [
      "Размером занимаемой входными данными памяти",
      "Количеством определённых подпрограмм",
      "Количеством основных операций",
      "Размером обрабатываемого массива или файла"
    ],
    "correct": 3
  },
  {
    "id": 35,
    "question": "Линейные списки находят применение в технологии:",
    "options": [
      "организации доменов Active Directory",
      "распределённых систем блокчейн",
      "символьной адресации узлов DNS",
      "реляционных баз данных"
    ],
    "correct": 1
  },
  {
    "id": 36,
    "question": "В основе алгоритма Кнута-Морриса-Пратта используется:",
    "options": [
      "Эвристика \"хороших\" суффиксов",
      "Эвристика стоп-символов (\"плохих\" символов)",
      "Префикс-функция",
      "Хеш-таблица"
    ],
    "correct": 2
  },
  {
    "id": 37,
    "question": "Для оценки порядка роста функций, описывающих вычислительную сложность алгоритмов, используются асимптотические обозначения (символики) или нотации. Что обозначает запись f(n)=ϴ(g(n)):",
    "options": [
      "Множество всех функций, порядок роста которых ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не меньше (больше или равен) некоторой константы c, умноженной на значение функции g(n)",
      "Множество всех функций, порядок роста которых не ограничен сверху и снизу функцией g(n) с точностью до постоянных множителей с1 и с2 соответственно",
      "Множество всех функций, порядок роста которых при достаточно больших n не больше(меньше или равен) некоторой константы c, умноженной на значение функции g(n)"
    ],
    "correct": 0
  },
  {
    "id": 38,
    "question": "Для каких узлов необходимо проверить коэффициент балансировки (баланс-фактор) после добавления узла в АВЛ-дерево?",
    "options": [
      "Для всех предков нового узла вплоть до корня дерева",
      "Только для нового добавленного узла",
      "Для всех узлов дерева",
      "Для родителя нового узла"
    ],
    "correct": 0
  },
  {
    "id": 39,
    "question": "Дисциплина обслуживания (порядок выполнения операций) стека:",
    "options": ["OFIL", "FIFO", "LOFI", "LIFO"],
    "correct": 3
  },
  {
    "id": 40,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в тексте по образцу методом Бойера-Мура в лучшем случае?",
    "options": [
      "f(n)=ϴ(n)",
      "f(n, m)=ϴ(log(n+m))",
      "f(n, m)=ϴ(log(n*m))",
      "f(n, m)=ϴ(log(n/m))"
    ],
    "correct": 3
  },
  {
    "id": 41,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма линейного (последовательного) поиска в худшем случае?",
    "options": ["f(n)=ϴ(n log(n))", "f(n)=ϴ(log(n))", "f(n)=ϴ(n2)", "f(n)=ϴ(n)"],
    "correct": 3
  },
  {
    "id": 42,
    "question": "Какие из перечисленных АВЛ-деревьев не требуют проведения перестройки?",
    "options": ["2, 3, 4", "1, 3, 4", "1, 2, 3", "1, 2, 4"],
    "correct": 3
  },
  {
    "id": 43,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма прямого поиска в тексте по образцу в худшем случае?",
    "options": ["f(n)=ϴ(n)", "f(n, m)=ϴ(log(n+m))", "f(n)=ϴ(n2)", "f(n, m)=ϴ(log(n*m))"],
    "correct": 2
  },
  {
    "id": 44,
    "question": "Когда один алгоритм считается эффективнее другого:",
    "options": [
      "Если его вычислительная сложность в наихудшем случае имеет более низкий порядок Роста",
      "Если его вычислительная сложность в наихудшем случае имеет более высокий порядок роста",
      "Если его вычислительная сложность в наилучшем случае имеет более низкий порядок роста",
      "Если его вычислительная сложность в наилучшем случае имеет более высокий порядок роста"
    ],
    "correct": 0
  },
  {
    "id": 45,
    "question": "При каком значении баланс-фактора b (т.е. разницы высот правого и левого поддеревьев) необходимо выполнить перестройку АВЛ-дерева?",
    "options": ["|b| = 0", "|b| = 2", "|b| = 1", "|b| > 2"],
    "correct": 1
  },
  {
    "id": 46,
    "question": "Какое из перечисленных АВЛ-деревьев требует балансировки?",
    "options": ["1", "3", "2", "4"],
    "correct": 1
  },
  {
    "id": 47,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма вставки ключа в бинарное дерево поиска в наилучшем случае?",
    "options": ["f(n)=О(n)", "f(n)=О(log(n))", "f(n)=О(1)", "f(n)=О(nlog(n))"],
    "correct": 1
  },
  {
    "id": 48,
    "question": "Зачем нужен заглавный элемент в двусвязном кольцевом списке?",
    "options": [
      "Чтобы иметь указатель на текущий элемент",
      "Чтобы указать на первый элемент",
      "Для связи последнего и первого элемента",
      "Для удаления пустых указателей"
    ],
    "correct": 1
  },
  {
    "id": 49,
    "question": "Какие основные операции следует учитывать при оценке временной (вычислительной) сложности алгоритмов сортировки:",
    "options": [
      "Все имеющиеся операции в алгоритме",
      "Операции перемещения данных",
      "Операции сравнения данных",
      "Операции сравнения и перемещения данных"
    ],
    "correct": 3
  },
  {
    "id": 50,
    "question": "Величина сдвига при поиске образца в тексте определяется наибольшим значением из трёх, вычисленных, соответственно, по трём правилам (эвристикам) в алгоритме:",
    "options": [
      "Бойера-Мура-Хорспула",
      "Кнута-Морриса-Прата",
      "Бойера-Мура с турбосдвигом",
      "Бойера-Мура"
    ],
    "correct": 3
  },
  {
    "id": 51,
    "question": "Суть алгоритма сортировки методом Шелла заключается в:",
    "options": [
      "Отдельной сортировке частей массива относительно опорного элемента",
      "Чередовании проходов по сортируемому массиву слева-направо и справа-налево",
      "Попарным сравнением элементов массива с целью выбора наименьшего",
      "Отдельной сортировке элементов, отстоящих друг от друга на расстоянии h, уменьшающемся на каждом проходе массива до значения 1"
    ],
    "correct": 3
  },
  {
    "id": 52,
    "question": "В чем смысл анализа алгоритма:",
    "options": [
      "Обеспечить безопасность данных",
      "Предсказать требуемые для его выполнения вычислительные ресурсы",
      "Определить требования к интерфейсу",
      "Предсказать форматы структур данных и внешние связи между ними"
    ],
    "correct": 1
  },
  {
    "id": 53,
    "question": "Алгоритмы сортировки выбором, обменом и вставкой называются простыми в смысле их:",
    "options": ["ёмкостной сложности", "временной сложности", "интеллектуальной сложности", "вычислительной сложности"],
    "correct": 2
  },
  {
    "id": 54,
    "question": "Что обеспечивает метод пробирования \"двойное хеширование\" при вставке элемента в хеш-таблицу, разрешающей коллизии по методу открытого адреса?",
    "options": [
      "Вычисление смещения, зависящее от значения ключа",
      "Эффективное рехеширование",
      "Вычисление смещения, не зависящее от значения ключа",
      "Длину первич"
    ],
    "correct": 0
  },
  {
    "id": 55,
    "question": "Известно, что при построении хеш-таблиц возможно появление коллизий. Коллизия это такая ситуация, когда:",
    "options": [
      "Определение области поиска производится с помощью учета знака разности между ключом и текущим значением элемента",
      "Для разных ключей хэш-функция может принимать одно и тоже значение h(ki) = h(kj)",
      "Способ нахождения промежуточных значений определяется величиной по имеющемуся дискретному набору значений",
      "Для одинаковых ключей хэш-функция может принимать разные значения h(ki) ≠ h(kj)"
    ],
    "correct": 1
  },
  {
    "id": 56,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма Дейкстры в графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E – количество ребер:",
    "options": ["f(n)=О(V)", "f(n)=О(E*log(V))", "f(n)=О(E)", "f(n)=О(V^2)"],
    "correct": 1
  },
  {
    "id": 57,
    "question": "Какая функция реализует линейную рекурсию:",
    "options": [
      "Содержит один вызов самой себя",
      "Содержит линейную функцию",
      "Количество вызовов самой себя определяется линейной функцией",
      "Содержит"
    ],
    "correct": 0
  },
  {
    "id": 58,
    "question": "Какой код будет получен из входной строки символов ABCCCDDDDD при использовании алгоритма Хаффмана?",
    "options": [
      "110 111 10 10 10 0 0 0 0 0 0",
      "1 2 3 3 3 4 4 4 4 4",
      "A1 B1 C3 D5",
      "00 01 10 10 10 11 11 11 11 11"
    ],
    "correct": 0
  },
  {
    "id": 59,
    "question": "Какая идея положена в основу построения алгоритма методом \"жадного алгоритма\"",
    "options": [
      "Осуществляется разбиение задачи на неперекрывающиеся подзадачи",
      "На каждом этапе осуществляется выбор решения, которое может не быть оптимальным в данный момент, но в результате решение станет оптимальным",
      "Осуществляется разбиение задачи на перекрывающиеся подзадачи",
      "На каждом этапе осуществляется выбор решения, которое кажется оптимальным в данный момент"
    ],
    "correct": 3
  },
  {
    "id": 60,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 44, 11, 7, 8, 42. Какова высота этого дерева?",
    "options": ["4", "3", "5", "2"],
    "correct": 0
  },
  {
    "id": 61,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов\n(1,3,5,2,4), (1,3,5,2,4), (1,3,2,5,4), (1,3,2,4,5),\n(1,3,2,4,5), (1,2,3,4,5), (1,2,3,4,5), (1,2,3,4,5)",
    "options": ["Простой вставки", "Простого выбора", "Простого обмена", "Шелла"],
    "correct": 2
  },
  {
    "id": 62,
    "question": "Что будет результатом применения алгоритма RLE (\"групповое кодирование\") к сжатию текста ААААААААААААААААААAВВВВВАААВВВВВBBС?",
    "options": [
      "(22)A(12)B(1)C",
      "ABАВC(19,5,3,7,1)",
      "19A5B3A7B1C",
      "ABC(19,5,3,7,1)"
    ],
    "correct": 2
  },
  {
    "id": 63,
    "question": "Нелинейными называются структуры данных, в которых:",
    "options": [
      "связи между элементами не зависят от упорядоченности значений элементов",
      "связи между элементами не зависят от линейной упорядоченности элементов",
      "связи между элементами зависят от выполнения определенного условия",
      "связи между элементами не зависят от выполнения какого-либо условия"
    ],
    "correct": 1
  },
  {
    "id": 64,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов\n(3,1,4,2,5), (3,1,2,4,5), (2,1,3,4,5), (1,2,3,4,5)",
    "options": ["Простого обмена", "Простой вставки", "Шелла", "Простого выбора"],
    "correct": 3
  },
  {
    "id": 65,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма поиска в ширину в неориентированном графе, построенном на списке смежных вершин, если V – количество вершин в графе, а E –количество ребер:",
    "options": ["f(n)=О(V2)", "f(n)=О(V log(E))", "f(n)=О(V+E)", "f(n)=О(V)"],
    "correct": 2
  },
  {
    "id": 66,
    "question": "Какой код будет получен из входной строки символов 1111223444 при использовании алгоритма группового кодирования RLE (Run Length Encoding)?",
    "options": [
      "0 0 0 0 01 01 10 11 11 11",
      "1-4-2-2-3-1-4-3",
      "41 22 13 34",
      "4 1 2 2 1 3 3 4"
    ],
    "correct": 3
  },
  {
    "id": 67,
    "question": "К недостаткам рекурсивного метода можно отнести:",
    "options": [
      "возможность переполнения стековой памяти программного процесса",
      "расход времени на выделение и очистку стекового кадра в памяти",
      "меньшая точность результата вычислений",
      "возможность переполнения динамически распределяемой памяти программного процесса"
    ],
    "correct": 0
  },
  {
    "id": 68,
    "question": "В теории вычислимости важную роль играет функция Аккермана A(m, n), определённая следующим образом: Вычислите значение A(2, 2). (Введите только число)",
    "options": ["7", "5", "6", "8"],
    "correct": 0
  },
  {
    "id": 69,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в среднем и наилучшем случаях?",
    "options": ["f(n)=ϴ(log(n))", "f(n)=ϴ(n log(n))", "f(n)=ϴ(n^2)", "f(n)=ϴ(n)"],
    "correct": 1
  },
  {
    "id": 70,
    "question": "Определите теоретическую вычислительную сложность (функцию роста времени) алгоритма:\n   for(int i = n/2; i < n; i++)\n      for(int j = 1; j < n; j = j*2) {\n       /* Последовательность шагов программы с временной сложностью O(1) */\n      }",
    "options": ["логарифмическая", "квадратичная", "линейная", "линейно-логарифмическая"],
    "correct": 3
  },
  {
    "id": 71,
    "question": "Сложность рекурсивного алгоритма вычисления N-ого числа Фибоначчи можно снизить с O(2^n) до О(n), т.е. оптимизировать процесс вычисления, если сохранять промежуточные значения решения подзадач. Какой метод построения алгоритма (алгоритмическая стратегия) здесь задействован?",
    "options": [
      "Динамическое программирование",
      "Метод рекурсии",
      "Разделяй и властвуй",
      "\"Жадный\" ал"
    ],
    "correct": 0
  },
  {
    "id": 72,
    "question": "Как определить, что функция реализует каскадную (множественную) рекурсию:",
    "options": [
      "Функция вызывает несколько внешних функций по любой из всех возможных ветвей алгоритма",
      "Функция вызывает последовательно несколько внешних функций",
      "Функция вызывает параллельно несколько внешних функций",
      "Вызов функции по любой из всех возможных ветвей алгоритма встречается более одного раза"
    ],
    "correct": 3
  },
  {
    "id": 73,
    "question": "Имеется линейный односвязный список из n (n>2) узлов. Структура узла списка:\nstruct Tnode {\n    Tdata data;\n    Tnode* next;\n}\nL - указатель на его начало. Укажите группу операторов, которые обеспечат корректное удаление двух узлов из начала списка L:",
    "options": [
      "q1=L; delete q1; q2=q1; L=q2->next; delete q2;",
      "q1=L; L=L->next->next; q2=L; delete q1; delete q2;",
      "q1=L; q2=L; L=q2->next; delete q1;delete q2;",
      "q1=L; q2=L->next; L=L->next->next; delete q1;delete q2;"
    ],
    "correct": 3
  },
  {
    "id": 74,
    "question": "Что проверяет условие Айверсона в алгоритме сортировки методом простого обмена:",
    "options": [
      "Количество элементов в неупорядоченной части массива",
      "Не пуст ли массив",
      "Наличие обменов в текущем проходе по массиву",
      "Наличие сравнений в тек"
    ],
    "correct": 2
  },
  {
    "id": 75,
    "question": "В результате применения алгоритма RLE был получен сжатый текст 9A-4ВCAВ7C. Какой текст был сжат этим алгоритмом?",
    "options": [
      "AAAAAAAAABACBCCCCCCC",
      "(9)A-BCAB(7)C",
      "AAAAAAAAABCABCCCCCCC",
      "AAAAAAAAABCABBCABBCABBCABCCCCCCC"
    ],
    "correct": 2
  },
  {
    "id": 76,
    "question": "Префиксный код в теории кодирования - это:",
    "options": [
      "кодовое слово фиксированной длины, с которого может начинаться другое кодовое слово",
      "кодовое слово переменной длины, с которого может начинаться другое кодовое слово",
      "кодовое слово фиксированной длины, с которого не может начинаться другое кодовое слово",
      "кодовое слово переменной длины, с которого не может начинаться другое кодовое слово того же кода"
    ],
    "correct": 3
  },
  {
    "id": 77,
    "question": "Когда алгоритм считается корректным:",
    "options": [
      "Когда для каждого ввода результатом его работы является корректный вывод",
      "Когда для каждого вывода результатом его работы является корректный ввод",
      "Когда для одного определённого ввода результатом его работы является корректный вывод",
      "Когда он может выдать ответ, отличный от ожидаемого"
    ],
    "correct": 0
  },
  {
    "id": 78,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом Шелла в наилучшем случае?",
    "options": ["f(n)=О(n)", "f(n)=О(n^2)", "f(n)=О(n log(n))", "f(n)=О(log(n))"],
    "correct": 0
  },
  {
    "id": 79,
    "question": "Алгоритм Флойда-Уоршала - это:",
    "options": [
      "Алгоритм поиска минимального остовного дерева во взвешенном неориентированном связном графе",
      "Алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных",
      "Алгоритм поиска заданного пользователем количества путей между двумя вершинами во взвешенном графе",
      "Алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа"
    ],
    "correct": 3
  },
  {
    "id": 80,
    "question": "Что предусматривает метод динамического программирования?",
    "options": [
      "Переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач",
      "Запоминание результатов решения тех подзадач, которые могут повторно Использоваться",
      "Получение решения исходно задачи путем комбинирования рекурсивных решений подзадач",
      "Выбор локально-оптимального решения каждой подзадачи для достижения оптимального конечного результата"
    ],
    "correct": 1
  },
  {
    "id": 81,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простой вставки в наилучшем случае:",
    "options": ["f(n)=О(n)", "f(n)=О(log(n))", "f(n)=О(n log(n))", "f(n)=О(n^2)"],
    "correct": 0
  },
  {
    "id": 82,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 15, 18, 10, 11, 7, 8, 17, 16. Из дерева удалили узел с ключом 18. Узел с каким значением был выбран замещающим?",
    "options": ["18", "16", "15", "17"],
    "correct": 3
  },
  {
    "id": 83,
    "question": "Как называется алгоритм для нахождения кратчайших путей от одной из вершин графа до всех остальных?",
    "options": ["Алгоритм Крускала", "Алгоритм Дейкстры", "Алгоритм Йена", "Алгоритм Флойда-Уоршала"],
    "correct": 1
  },
  {
    "id": 84,
    "question": "Чем может быть вызвано переполнение стека при выполнении рекурсивной функции с небольшой глубиной рекурсии:",
    "options": [
      "Неправильно оформленным выводом результата",
      "Неправильно сформулированным условием завершения рекурсии",
      "Неправильным выполнением вызова функции",
      "Неправильно оформленным блоком входа в рекурсию"
    ],
    "correct": 1
  },
  {
    "id": 85,
    "question": "Что определяет структура данных:",
    "options": [
      "Множество данных",
      "Множество данных и отношений между ними",
      "Множество данных и множество операций над ними",
      "Множество отношений между данными в форме операций над ними"
    ],
    "correct": 2
  },
  {
    "id": 86,
    "question": "Дано описание функции:\nint f(int x) { return (x == 0) ? 1 : x * f(x-1); }\nДанная функция вычисляет:",
    "options": ["факториал числа n", "n-ое простое число", "n-ое число Фибоначчи", "степень числа n"],
    "correct": 0
  },
  {
    "id": 87,
    "question": "Алгоритм обхода графа - это:",
    "options": [
      "Алгоритм, указывающий несколько путей обработки одних и тех же входных данных, без какого-либо уточнения, какой именно вариант будет выбран",
      "Алгоритм, устанавливающий переход от одной его вершины к другой с целью нахождения кратчайшего пути",
      "Алгоритм, устанавливающий переход от одной его вершины к другой в поисках свойств связей этих вершин",
      "Алгоритм, устанавливающий движение от начальной вершины в определенном направлении (по определенному пути) до тех пор, пока не будет достигнут конец пути или заданная вершина"
    ],
    "correct": 3
  },
  {
    "id": 88,
    "question": "Структура хранения, обеспечивающая прямой доступ к каждому элементу данных, т.е. время доступа к значению О(1):",
    "options": ["сетевая", "иерархическая", "списочная", "векторная"],
    "correct": 3
  },
  {
    "id": 89,
    "question": "При создании бинарного дерева поиска ключи поступали в следующей последовательности: 25, 12, 13, 10, 11, 7, 8, 44, 42. В это дерево был вставлен узел с ключом 6. В какое поддерево и какого узла был вставлен узел?",
    "options": [
      "В левое поддерево узла 11",
      "В левое поддерево узла 7",
      "В левое поддерево узла 13",
      "В левое поддерево узла 42"
    ],
    "correct": 1
  },
  {
    "id": 90,
    "question": "Имеется следующее оптимальное кодовое дерево (ОКД):\nВыберите исходную строку, которая была закодирована в битовый код 111 0 0 10 10 0 110 0 10 0 по алгоритму Хаффмана с использованием приведенного ОКД:",
    "options": ["DDDDDCCCBA", "BDDCCDADCD", "ABDCDCDCDD", "ABCCCDD"],
    "correct": 1
  },
  {
    "id": 91,
    "question": "Как называется алгоритм, который напрямую или через другие вспомогательные алгоритмы вызывает сам себя:",
    "options": ["Разветвляющийся", "Циклический", "Рекурсивный", "Линейный"],
    "correct": 2
  },
  {
    "id": 92,
    "question": "Росту первичного кластера в хеш-таблице с открытым адресом способствует:",
    "options": [
      "Смещение и размер таблицы имеют общие множители",
      "Размер таблицы определен как простое число и смещение простое число",
      "Для большого количества ключей хеш-функция сформировала один и тот же индекс",
      "Ключи равномерно распределены по та"
    ],
    "correct": 0
  },
  {
    "id": 93,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки методом простого обмена (с условием Айверсона) в наилучшем случае:",
    "options": ["f(n)=О(n log(n))", "f(n)=О(log(n))", "f(n)=О(n)", "f(n)=О(n^2)"],
    "correct": 2
  },
  {
    "id": 94,
    "question": "К графу на рисунке 1 применен алгоритм обхода в глубину. Какое из остовных деревьев соответствует обходу в глубину с вершины 3?",
    "options": ["2", "5", "3", "4"],
    "correct": 3
  },
  {
    "id": 95,
    "question": "Что помещается в стек рекурсивных вызовов при вызове рекурсивной функции?",
    "options": [
      "Значения всех переменных функции при текущем вызове для возврата в точку вызова",
      "Описание всех переменных функции при текущем вызове",
      "Имена локальных переменных и параметров функции",
      "Адрес точки возврата, значения всех переменных функции текущего вызова"
    ],
    "correct": 3
  },
  {
    "id": 96,
    "question": "Чему равна сумма степеней вершин графа?",
    "options": [
      "Числу его ребер",
      "Удвоенному числу его ребер",
      "Сумме веса ребер",
      "Удвоенному весу ребер"
    ],
    "correct": 1
  },
  {
    "id": 97,
    "question": "Имеется бинарное дерево поиска, содержащее целые числа от 1 до 7. Каким будет результат вывода при обратном обходе дерева (postoder):",
    "options": [
      "4, 1, 2, 3, 5, 6, 7",
      "1, 2, 3, 4, 5, 6, 7",
      "4, 1, 5, 2, 6, 3, 7",
      "7, 6, 5, 4, 3, 2, 1"
    ],
    "correct": 3
  },
  {
    "id": 98,
    "question": "Каков главный недостаток хеш-таблиц?",
    "options": [
      "В отказе на повторное хеширование",
      "В трудоёмкой функции хеширования",
      "Фиксированный размер, при неизвестном окончательном числе элементов",
      "Фиксированное число эл"
    ],
    "correct": 2
  },
  {
    "id": 99,
    "question": "Выберите код, являющийся результатом сжатия по методу скользящего окна текста \"abacabacabadaca\". Примечание: кавычки ограничивают текст и не кодируются.",
    "options": [
      "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(2,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(4,4,d)(2,1,c)(2,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(4,7,d)(2,1,c)(4,1,пусто)",
      "(0,0,a)(0,0,b)(2,1,c)(3,7,d("
    ],
    "correct": 0
  },
  {
    "id": 100,
    "question": "Диапазон допустимых значений простого типа данных определяется разрядностью отдельного значения этого типа. В перечне примеров найдите неправильный вариант:",
    "options": [
      "char – занимает 1 байт, следовательно, имеет диапазон от –128 до +127",
      "short int – занимает 2 байта, следовательно, имеет диапазон от –32 768 до +32 767",
      "long int – занимает 4 байта, следовательно, имеет диапазон от –2 147 483 648 до +2 147 483 647",
      "int – занимает 4 байта, следовательно, имеет диапазон от –2 148 483 647 до +2 147 483 647"
    ],
    "correct": 3
  },
  {
    "id": 101,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки шейкерным методом (с условием Айверсона) в наихудшем случае:",
    "options": ["f(n)=О(log(n))", "f(n)=О(n^2)", "f(n)=О(n log(n))", "f(n)=О(n^3)"],
    "correct": 1
  },
  {
    "id": 102,
    "question": "Какой алгоритм из перечисленных не основан на жадном подходе?",
    "options": [
      "Алгоритм нахождения кратчайшего пути Беллмана-Форда",
      "Алгоритм нахождения кратчайшего пути Дейкстры",
      "Алгоритм кодирования Хаффмана",
      "Алгоритм построения минимального остовного дерева Крускала"
    ],
    "correct": 0
  },
  {
    "id": 103,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма сортировки слиянием (Mergesort) в среднем и наихудшем случаях:",
    "options": ["f(n)=ϴ(n)", "f(n)=ϴ(n^2)", "f(n)=ϴ(log(n))", "f(n)=ϴ(n log(n))"],
    "correct": 3
  },
  {
    "id": 104,
    "question": "Что хранит матрица смежности графа?",
    "options": [
      "Список ребер и их направление",
      "Список вершин",
      "Длину пути между вершинами графа",
      "Только направления"
    ],
    "correct": 0
  },
  {
    "id": 105,
    "question": "Система байтового кодирования символов ASCII кодирует символы входной последовательности кодами:",
    "options": [
      "переменной длины до одного байта",
      "фиксированной длины в один байт",
      "хеш-кодами",
      "переменной длины свыше одного байта"
    ],
    "correct": 1
  },
  {
    "id": 106,
    "question": "Для динамической структуры данных (переменной) справедливо утверждение:",
    "options": [
      "создается на этапе компиляции кода и размер не может быть изменен во время выполнения программы",
      "создается на этапе выполнения программы и размер может быть изменен на этапе выполнения",
      "создается на этапе компиляции кода и размер может быть изменен во время выполнения программы",
      "создается на этапе выполнения программы и размер не может быть изменен на этапе выполнения"
    ],
    "correct": 1
  },
  {
    "id": 107,
    "question": "Как называется алгоритм для нахождения кратчайших путей между всеми вершинами взвешенного ориентированного графа?",
    "options": ["Алгоритм Флойда-Уоршала", "Алгоритм Дейкстры", "Алгоритм Крускала", "Алгоритм Прима"],
    "correct": 0
  },
  {
    "id": 108,
    "question": "Дана следующая рекурсивная функция:\nint fib(int n) {\nif (n <2) { return 1; }\nelse { return fib(n - 2) + fib(n - 1); }\n}\nКакова высота дерева рекурсии при вызове fib(5)",
    "options": ["7", "4", "3", "5"],
    "correct": 0
  },
  {
    "id": 109,
    "question": "Метод сортировки считается устойчивым, если:",
    "options": [
      "время доступа к значению константное",
      "относительное расположение элементов с равными ключами всегда изменяется",
      "начальная отсортированность массива не важна",
      "относительное расположение элементов с равными ключами не изменяется"
    ],
    "correct": 3
  },
  {
    "id": 110,
    "question": "Свойство алгоритма, обеспечивающее возможность его использования для решения множества однотипных задач (применимость к различным наборам входных данных), называется:",
    "options": ["Массовость", "Результативность", "Дискретность", "Завершаемость"],
    "correct": 0
  },
  {
    "id": 111,
    "question": "Какой алгоритм сортировки из перечисленных ниже будет самым эффективным на уже отсортированном массиве?",
    "options": ["Вставками", "пирамидальная", "быстрая сортировка", "слиянием"],
    "correct": 0
  },
  {
    "id": 112,
    "question": "Что будет результатом применения алгоритма RLE - \"Групповое кодирование\" к сжатию текста ААААААААААААААААААВCAВCAСCCCCC?",
    "options": [
      "A(18)BCA(2)C(6)",
      "18A-6ВCAВCA6C",
      "18A-2BCA6C",
      "A18ABCABC6C"
    ],
    "correct": 0
  },
  {
    "id": 113,
    "question": "Понятие \"глубина рекурсии\" для рекурсивной функции определяет:",
    "options": [
      "Наибольшее одновременное количество рекурсивных обращений функции",
      "Количество операторов вызова функции в самой функции",
      "Наибольшее количество операторов в рекурсивной функции",
      "Количество внешних вызовов функции в программе"
    ],
    "correct": 0
  },
  {
    "id": 114,
    "question": "Какой алгоритм реализует стратегию \"разделяй и властвуй\" (divide and conquer approach)?",
    "options": [
      "алгоритм Дейкстры",
      "алгоритм Бойера-Мура",
      "алгоритм быстрой сортировки Quick-sort",
      "алгоритм Крускала"
    ],
    "correct": 2
  },
  {
    "id": 115,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма пирамидальной сортировки (Heapsort) в среднем случае?",
    "options": ["f(n)=О(n log(n))", "f(n)=О(n)", "f(n)=О(n^2)", "f(n)=О(log(n))"],
    "correct": 0
  },
  {
    "id": 116,
    "question": "Есть ли ошибка в коде функции f, которая осуществляет получение ссылки на последний узел линейного односвязного списка со структурой узла? struct Tnode{ Tdata data; Tnode* next;}; Tnode *f(Tnode *L) {     Tnode *q=L;     while(q) { q=q->next; }     return q; }",
    "options": [
      "Ошибка в записи оператора q=q->next",
      "Ошибки нет",
      "Ошибка в условии while (q) - должно быть while (q->next)",
      "Ошибка в записи оператора Tnode *q=L - должно быть Tnode q=L"
    ],
    "correct": 2
  },
  {
    "id": 117,
    "question": "Как называется алгоритм, который выполнит сортировку исходного массива (3,1,5,2,4) следующей последовательностью проходов (1,3,5,2,4), (1,3,5,2,4), (1,2,3,5,4), (1,2,3,4,5)",
    "options": ["Простой вставки", "Простого выбора", "Пирамидальная", "Простого обмена"],
    "correct": 0
  },
  {
    "id": 118,
    "question": "Прямой доступ к элементу данных в памяти делает возможным:",
    "options": [
      "порядковый номер элемента в структуре",
      "идентификатор элемента в программе",
      "любая списочная структура",
      "адрес элемента в ОЗУ"
    ],
    "correct": 3
  },
  {
    "id": 119,
    "question": "Какая структура данных используется для хранения элементов данных в хеш-таблице, при реализации разрешения коллизий по методу цепочек (цепного хеширования)?",
    "options": ["Дек", "Однонаправленный список", "Двоичное дерево", "Очередь"],
    "correct": 1
  },
  {
    "id": 120,
    "question": "Исходный текст \"abcdabcdaaacc\" был сжат, в результате был получен код abcd(4,4)(8,1)(1,1)(1,1) (5,1). Какой принцип сжатия текстовой информации при этом использовался?",
    "options": [
      "уменьшение объема текста за счет формирования словаря кодов цепочек и замены цепочек на код",
      "частотное кодирование",
      "уменьшение объема текста за счет замены каждой повторно встреченной цепочки символов комбинацией: (количество знаков в цепочке, цепочка символов)",
      "уменьшение объема текста за счет замены повторно встретившейся цепочки символов ссылкой на ранее встреченную цепочку"
    ],
    "correct": 3
  },
  {
    "id": 121,
    "question": "Какая проблема может возникнуть в хеш-таблице с открытым адресом, после удаления ключа из первичного кластера ключей, хешированных с одним индексом?",
    "options": [
      "Невозможность найти ключ в первичном кластере",
      "Ключи поменяют индексы, с которыми были хешированы при вставке в таблицу",
      "Неоднозначность результата поиска ключа",
      "Невозможно вставить ключ в первичный кластер"
    ],
    "correct": 0
  },
  {
    "id": 122,
    "question": "Что делает следующая функция? int trinity (int a, int b, int c) {    if ((a >= b) && (c= b) return trinity (a,c,b);    else return trinity (b,a,c); }",
    "options": [
      "ничего из перечисленного",
      "вычисляет минимальное значение",
      "вычисляет максимальное значение",
      "вычисляет среднее значение"
    ],
    "correct": 3
  },
  {
    "id": 123,
    "question": "Какой зависимостью описывается функция вычислительной сложности алгоритма быстрой сортировки методом Хоара (quicksort) в наихудшем случае:",
    "options": ["f(n)=О(n^2)", "f(n)=О(log(n))", "f(n)=О(n log(n))", "f(n)=О(n^3)"],
    "correct": 0
  },
  {
    "id": 124,
    "question": "Каков максимальный размер кодового слова, полученного алгоритмом Шеннона-Фано, для текста, частота появления символов в котором определяется таблицей: а-11,и-8,пробел - 6, л-4, п-3, с-3, м-2, ы-2, н-1, ш-1, ч-1, к-1, у-1, т-1, ь-1?",
    "options": ["6", "5", "7", "4"],
    "correct": 0
  }
];
    const shuffled = originalQuizData.map(q => shuffleQuestionOptions(q));
    setQuestions(shuffled);
  };

  if (questions.length === 0) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center">
          <div className="inline-block animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-indigo-600 mb-4"></div>
          <p className="text-gray-600">Загрузка вопросов...</p>
        </div>
      </div>
    );
  }

  const question = questions[currentQuestion];
  const isAnswered = answeredQuestions.has(currentQuestion);
  const progressPercentage = ((currentQuestion + 1) / questions.length) * 100;

  return (
    <div className="min-h-screen p-4 md:p-8">
      <div className="max-w-3xl mx-auto">
        <div className="bg-white rounded-2xl shadow-xl p-6 md:p-8 mb-6">
          <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
            <h1 className="text-2xl md:text-3xl font-bold text-gray-800">
              Тест по алгоритмам и структурам данных
            </h1>
            <button
              onClick={resetQuiz}
              className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors w-full md:w-auto justify-center"
            >
              <Icon name="RotateCcw" size={20} />
              Начать заново
            </button>
          </div>

          <div className="mb-6">
            <div className="flex justify-between text-sm text-gray-600 mb-2">
              <span>Вопрос {currentQuestion + 1} из {questions.length}</span>
              <span>Правильных: {score} / {answeredQuestions.size}</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div
                className="bg-gradient-to-r from-indigo-500 to-purple-600 h-2.5 rounded-full transition-all duration-500 ease-out"
                style={{ width: `${progressPercentage}%` }}
              />
            </div>
          </div>

          <div className="mb-8">
            <h2 className="text-lg md:text-xl font-semibold text-gray-800 mb-6 whitespace-pre-wrap bg-gray-50 p-4 rounded-lg border border-gray-200">
              {question.question}
            </h2>
            <div className="space-y-3">
              {question.options.map((option, index) => {
                const isCorrect = index === question.correct;
                const isSelected = selectedAnswer === index;
                let buttonClass = "w-full text-left p-4 rounded-xl border-2 transition-all duration-200 option-button ";
                if (!isAnswered) {
                  buttonClass += "border-gray-200 hover:border-indigo-400 hover:bg-indigo-50";
                } else {
                  if (isCorrect) {
                    buttonClass += "border-green-500 bg-green-50 text-green-800";
                  } else if (isSelected && !isCorrect) {
                    buttonClass += "border-red-500 bg-red-50 text-red-800";
                  } else {
                    buttonClass += "border-gray-200 opacity-60";
                  }
                }
                return (
                  <button
                    key={index}
                    onClick={() => handleAnswer(index)}
                    disabled={isAnswered}
                    className={buttonClass}
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-start">
                        <div className={`w-6 h-6 flex items-center justify-center rounded-full mr-3 flex-shrink-0 ${
                          !isAnswered ? 'bg-gray-100' :
                          isCorrect ? 'bg-green-100 text-green-600' :
                          isSelected && !isCorrect ? 'bg-red-100 text-red-600' :
                          'bg-gray-100 text-gray-400'
                        }`}>
                          {String.fromCharCode(65 + index)}
                        </div>
                        <span className="whitespace-pre-wrap text-left">{option}</span>
                      </div>
                      {showResult && isCorrect && (
                        <Icon name="CheckCircle" className="text-green-600 flex-shrink-0 ml-2" size={24} />
                      )}
                      {showResult && isSelected && !isCorrect && (
                        <Icon name="XCircle" className="text-red-600 flex-shrink-0 ml-2" size={24} />
                      )}
                    </div>
                  </button>
                );
              })}
            </div>
          </div>

          <div className="flex flex-col sm:flex-row justify-between items-center gap-4">
            <button
              onClick={prevQuestion}
              disabled={currentQuestion === 0}
              className="flex items-center gap-2 px-6 py-3 bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg transition-colors w-full sm:w-auto justify-center order-2 sm:order-1"
            >
              <Icon name="ChevronLeft" size={20} />
              Назад
            </button>
            <div className="text-center order-1 sm:order-2">
              <p className="text-sm text-gray-600">
                {answeredQuestions.size} из {questions.length} отвечено
              </p>
              <p className="text-xs text-gray-500 mt-1">
                {Math.round((answeredQuestions.size / questions.length) * 100)}% завершено
              </p>
            </div>
            <button
              onClick={nextQuestion}
              disabled={currentQuestion === questions.length - 1}
              className="flex items-center gap-2 px-6 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white disabled:opacity-50 disabled:cursor-not-allowed rounded-lg transition-colors w-full sm:w-auto justify-center order-3"
            >
              Далее
              <Icon name="ChevronRight" size={20} />
            </button>
          </div>
        </div>

        {answeredQuestions.size === questions.length && (
          <div className="bg-white rounded-2xl shadow-xl p-8 text-center animate-fadeIn">
            <div className="w-20 h-20 bg-gradient-to-r from-green-100 to-emerald-100 rounded-full flex items-center justify-center mx-auto mb-6">
              <div className="text-3xl font-bold text-green-600">{score}/{questions.length}</div>
            </div>
            <h2 className="text-3xl font-bold text-gray-800 mb-4">Тест завершён!</h2>
            <p className="text-xl text-gray-600 mb-2">
              Ваш результат: {score} из {questions.length}
            </p>
            <p className="text-lg text-gray-500 mb-6">
              ({Math.round((score / questions.length) * 100)}%)
            </p>
            <div className="flex flex-col sm:flex-row gap-4 justify-center">
              <button
                onClick={resetQuiz}
                className="px-6 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 hover:from-indigo-700 hover:to-purple-700 text-white rounded-lg transition-colors"
              >
                Пройти ещё раз
              </button>
              <button
                onClick={() => setCurrentQuestion(0)}
                className="px-6 py-3 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors"
              >
                Посмотреть ответы
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

// Анимация
const style = document.createElement('style');
style.textContent = `
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}
.animate-fadeIn {
  animation: fadeIn 0.5s ease-out;
}
`;
document.head.appendChild(style);

ReactDOM.render(<QuizApp />, document.getElementById('root'));
</script>
</body>
</html>